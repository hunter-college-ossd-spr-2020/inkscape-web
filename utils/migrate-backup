#!/usr/bin/python
"""
Open django json dumps and update them to the latest versions so they
can be continued to be used as backups going forwards.

Usage: %s <content.json>
"""

import os
import sys
import json

from collections import defaultdict
from subprocess import PIPE, Popen
from urllib2 import urlopen

VERBOSE = '-v' in sys.argv
if VERBOSE:
    sys.argv.remove('-v')

def delete(field, row, **kwargs):
    if row.has_key(field):
        row.pop(field)
        return True
    return False

def set_to(field, r, where=None, value=None, row=None, **kwargs):
    if where and row[where] != value:
        return False
    if row.has_key(field) and row[field] != r:
        row[field] = r
        return True
    return False

def add_to(field, r, row, **kwargs):
    if not row.has_key(field):
        row[field] = r
        return True
    return False

def update_cms(field, row, **kwargs):
    if '.html' in row[field] and not row[field].startswith('cms/'):
        row[field] = "cms/" + row[field]
        return True
    return False

TRACK = defaultdict(list)
def unique(field, item, row, model, delete, **kwargs):
    global TRACK
    if row[field] in TRACK[model]:
        delete.append(item)
    else:
        TRACK[model].append(row[field])

LIVE_URL = 'https://inkscape.org/media'
LOCAL_MEDIA = os.path.abspath(
    os.path.join(os.path.dirname(__file__), '..', 'data', 'media'))
def download(field, row, **kwargs):
    """Downloads a media item from live website"""
    if not os.path.exists(LOCAL_MEDIA):
        raise IOError("Can't find local media directory: %s" % str(LOCAL_MEDIA))

    media = row[field]
    local_path = os.path.join(LOCAL_MEDIA, media)
    local_dir  = os.path.dirname(local_path)

    if os.path.isfile(local_path):
        sys.stderr.write("Skipping: %s\n" % media)
        return True

    try:
        response = urlopen('%s/%s' % (LIVE_URL, media))
        sys.stderr.write("Downloading: %s\n" % media)
    except Exception:
        sys.stderr.write("Error getting: %s\n" % media)
        return False

    if not os.path.isdir(local_dir):
        os.makedirs(local_dir)

    with open(local_path, 'wb') as fhl:
        fhl.write(response.read())
    

MANAGE = os.path.join(os.path.dirname(__file__), 'manage')
try:
    A_USER = int( Popen([MANAGE, 'getauser'], stdout=PIPE).stdout.read().strip() )
except ValueError:
    sys.stderr.write("Can't restore data with no admin user setup.")
    sys.exit(1)

UPDATES = {
  'cms.page': (
    [ delete, 'moderator_state' ],
    [ update_cms, 'template' ],
  ),
  'cms.usersettings': (
    [ set_to, 'user', A_USER ],
    [ unique, 'user' ],
  ),
  # Set the creator to admin account
  'cmsplugin_news.news': (
    [ set_to, 'creator', A_USER ],
    [ set_to, 'editor', A_USER ],
  ),
  'djangocms_file.file': (
    [ download, 'file' ],
  ),
  'djangocms_picture.picture': (
    [ download, 'image' ],
  ),
  'extra.tabcategory': (
    [ download, 'icon' ],
  ),
  'extra.tab': (
    [ download, 'download' ],
    [ set_to, 'user', A_USER ],
  ),
}

def log(message):
    if VERBOSE:
        sys.stderr.write(message+"\n")

def update(content, updates):
    WARNED = []
    DELETE = []
    COUNT = {}

    for item in content:
        model = item['model']
        update = updates.get(model, [])

        if not update:
            if model not in WARNED:
                log("No updates for %s" % model)
                WARNED.append(model)
            continue
        COUNT[model] = COUNT.setdefault(model, {})
        for up in update:
            kwargs = dict(row=item['fields'], item=item, model=model, delete=DELETE)
            if up[0](*up[1:], **kwargs):
                COUNT[model][up[1]] = COUNT[model].setdefault(up[1], 0) + 1

    for d in DELETE:
        content.remove(d)

    for model, counts in COUNT.iteritems():
        log("Migrated %s: %s" % (model, str(counts)))


if __name__ == '__main__':
    if len(sys.argv) == 1 or (sys.argv[1] != '-' and not os.path.exists(sys.argv[1])):
        sys.stderr.write(__doc__) % sys.argv[0]
        sys.exit(1)

    if sys.argv[1] == '-':
        content = json.loads(sys.stdin.read())
    else:
        with open(sys.argv[1], 'r') as fhl:
            content = json.loads(fhl.read())
    update(content, UPDATES)
    print json.dumps(content)

